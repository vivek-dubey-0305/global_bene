import { asyncHandler } from "../middlewares/asyncHandler.middleware.js";
import { Post } from "../models/post.model.js";
import { Community } from "../models/community.model.js";
import { Notification } from "../models/notification.model.js";
import { User } from "../models/user.model.js";
import { ApiError } from "../utils/ApiError.js";
import { ApiResponse } from "../utils/ApiResponse.js";
import { uploadOnCloudinary } from "../utils/cloudinary.utils.js";
import { cloudinaryPostRefer } from "../utils/constants.utils.js";
import { logActivity } from "../utils/logActivity.utils.js";
import { Report } from "../models/report.model.js";
import ErrorHandler from "../middlewares/error.middleware.js";
import { getRecommendations, refreshRecommendations } from "../utils/recommendation.utils.js";
// Create a new post
export const createPost = asyncHandler(async (req, res) => {
    console.log("req.body:", req.body);
    console.log("req.file:", req.file);
    console.log("req.user:", req.user);
    const { title, body, communityId, type, url, tags } = req.body;
    const author = req.user._id;

    if (!title || !communityId) {
        throw new ApiError(400, "Title and communityId are required");
    }

    // Content is optional for all post types
    // if (type === 'text' && !body) {
    //     throw new ApiError(400, "Body is required for text posts");
    // }

    const community = await Community.findById(communityId);
    console.log("community:", community);
    if (!community) {
        throw new ApiError(404, "Community not found");
    }

    if (!community.members.some(member => member && member.toString() === author.toString())) {
        throw new ApiError(403, "You must be a member of the community to post");
    }

    let media = null;
    // Handle file upload for any post type
    if (req.file) {
        const uploadedMedia = await uploadOnCloudinary(req.file.path, cloudinaryPostRefer, req.user, req.file.originalname);
        if (uploadedMedia) {
            media = {
                public_id: uploadedMedia.public_id,
                secure_url: uploadedMedia.secure_url
            };
        }
    }

    const post = await Post.create({
        title,
        body: body || "",
        author_id: author,
        community_id: communityId,
        type: type || "text",
        media,
        url: url || "",
        tags: [...(tags || []), ...(req.autoTags || [])], // Merge manual and auto tags
        status: req.newReport ? 'flagged' : 'active',
        label: req.detectionLabel || req.newReport?.label || 'safe',
        isSensitive: req.isSensitive || false
    });




    // If a report was generated by spamDetector middleware, save it
    if (req.newReport) {
        try {
            // remove extra fields from report
            delete req.newReport?.label;

            req.newReport.target_type = "Post";
            req.newReport.target_id = post._id;

            const report = await Report.create(req.newReport);
            console.log("------Report Generated For Post--------");
            console.log(report);
            console.log("--------------");
        } catch (err) {
            console.log("Error in creating report for post update:", err.message);
            return res.send({ message: "Post created but failed to create report" });
        }
    }

    await post.populate('author_id', 'username avatar');
    await post.populate('community_id', 'title');

    await logActivity(
        author,
        "post",
        `${req.user.username || req.user.email?.split('@')[0] || 'User'} created a post: ${title}`,
        req,
        'post',
        post._id
    );

    // Increment num_posts for author
    await User.findByIdAndUpdate(author, { $inc: { num_posts: 1 } });

    res.status(201).json(new ApiResponse(201, post, "Post created successfully"));
});

// Get all posts (with pagination and filtering)
export const getAllPosts = asyncHandler(async (req, res) => {
    const { page = 1, limit = 10, communityName, sortBy = "createdAt", includeFlagged = false } = req.query;

    const filter = {};
    if (!includeFlagged) {
        filter.status = 'active';
    }
    if (communityName) {
        const community = await Community.findOne({ name: communityName.toLowerCase() });
        if (community) {
            filter.community_id = community._id;
        } else {
            return res.status(200).json(new ApiResponse(200, {
                posts: [],
                totalPages: 0,
                currentPage: page,
                totalPosts: 0
            }, "Posts fetched successfully"));
        }
    }

    const posts = await Post.find(filter)
        .populate('author_id', 'username avatar')
        .populate('community_id', 'title members')
        .sort({ [sortBy]: -1 })
        .limit(limit * 1)
        .skip((page - 1) * limit);

    const totalPosts = await Post.countDocuments(filter);

    res.status(200).json(new ApiResponse(200, {
        posts,
        totalPages: Math.ceil(totalPosts / limit),
        currentPage: page,
        totalPosts
    }, "Posts fetched successfully"));
});

// Get posts by user
export const getPostsByUser = asyncHandler(async (req, res) => {
    const { userId } = req.params;
    const { page = 1, limit = 10, sortBy = "createdAt" } = req.query;

    const posts = await Post.find({ author_id: userId })
        .populate('author_id', 'username avatar')
        .populate('community_id', 'title members')
        .sort({ [sortBy]: -1 })
        .limit(limit * 1)
        .skip((page - 1) * limit);

    const totalPosts = await Post.countDocuments({ author_id: userId });

    res.status(200).json(new ApiResponse(200, {
        posts,
        totalPages: Math.ceil(totalPosts / limit),
        currentPage: page,
        totalPosts
    }, "User posts fetched successfully"));
});

// Get post by ID
export const getPostById = asyncHandler(async (req, res) => {
    const { id } = req.params;

    const post = await Post.findById(id)
        .populate('author_id', 'username avatar')
        .populate('community_id', 'title members')
        .populate('upvotes', 'username')
        .populate('downvotes', 'username');

    if (!post) {
        throw new ApiError(404, "Post not found");
    }

    res.status(200).json(new ApiResponse(200, post, "Post fetched successfully"));
});

// Update post (only author)
export const updatePost = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const { title, body } = req.body;
    const userId = req.user._id;

    const post = await Post.findById(id);
    if (!post) {
        throw new ApiError(404, "Post not found");
    }

    if (post.author_id.toString() !== userId.toString()) {
        throw new ApiError(403, "Only author can update post");
    }

    post.title = title || post.title;
    post.body = body || post.body;
    post.label = req.detectionLabel || req.newReport?.label || 'safe';
    post.status = req.newReport ? 'flagged' : 'active';
    post.isSensitive = req.isSensitive || post.isSensitive;
    if (req.autoTags) {
        post.tags = [...new Set([...(post.tags || []), ...req.autoTags])]; // Merge without duplicates
    }


    // If a report was generated by spamDetector middleware, save it
    if (req.newReport) {
        try {
            // remove extra fields from report
            delete req.newReport?.label;

            req.newReport.target_type = "Post";
            req.newReport.target_id = post._id;

            const report = await Report.create(req.newReport);
            console.log("------Report Generated For Post--------");
            console.log(report);
            console.log("--------------");
        } catch (err) {
            console.log("Error in creating report for post update:", err.message);
            return res.send({ message: "Post updated but failed to create report" });
        }

    }


    await post.save();
    await post.populate('author_id', 'username avatar');
    await post.populate('community_id', 'title');

    await logActivity(
        userId,
        "update-post",
        `${req.user.username || req.user.email || 'User'} updated post: ${post.title}`,
        req,
        'post',
        id
    );

    res.status(200).json(new ApiResponse(200, post, "Post updated successfully"));
});

// Delete post (author or moderator)
export const deletePost = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user._id;

    const post = await Post.findById(id).populate('community_id');
    if (!post) {
        throw new ApiError(404, "Post not found");
    }

    const isAuthor = post.author_id.toString() === userId.toString();
    const isModerator = post.community_id.moderators.includes(userId);

    if (!isAuthor && !isModerator) {
        throw new ApiError(403, "Only author or moderator can delete post");
    }

    // If author deletes, set status to removed and clear body
    if (isAuthor) {
        post.status = 'removed';
        post.body = '';
        await post.save();
    } else {
        // Moderator deletes, actually delete
        await Post.findByIdAndDelete(id);
    }

    await logActivity(
        userId,
        "delete-post",
        `${req.user.username || req.user.email || 'User'} deleted post: ${post.title}`,
        req,
        'post',
        id
    );

    // Decrement num_posts if author deleted
    if (isAuthor) {
        await User.findByIdAndUpdate(userId, { $inc: { num_posts: -1 } });
    }

    res.status(200).json(new ApiResponse(200, null, "Post deleted successfully"));
});

// Upvote post
export const upvotePost = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user._id;

    const post = await Post.findById(id).populate('author_id');
    if (!post) {
        throw new ApiError(404, "Post not found");
    }

    const hasUpvoted = post.upvotes.includes(userId);
    const hasDownvoted = post.downvotes.includes(userId);

    let notification = null;
    if (hasUpvoted) {
        // Remove upvote
        post.upvotes = post.upvotes.filter(id => id.toString() !== userId.toString());
    } else {
        // Add upvote and remove downvote if exists
        post.upvotes.push(userId);
        if (hasDownvoted) {
            post.downvotes = post.downvotes.filter(id => id.toString() !== userId.toString());
        }

        await logActivity(
            userId,
            "upvote",
            `${req.user.username || req.user.email || 'User'} upvoted post`,
            req,
            'post',
            id
        );

        // Create notification if not self-vote
        if (post.author_id.toString() !== userId.toString()) {
            notification = await Notification.create({
                user: post.author_id,
                type: "upvote",
                message: `${req.user.username || req.user.email || 'User'} upvoted your post`,
                relatedPost: id
            });
        }

        // Refresh recommendations after upvote
        await refreshRecommendations(userId);
    }

    // Calculate score
    post.score = post.upvotes.length - post.downvotes.length;

    await post.save();
    await post.populate('upvotes', 'username');
    await post.populate('downvotes', 'username');

    // Emit vote update to post room
    global.io.to(`post_${id}`).emit('vote-updated', {
        postId: id,
        upvotes: post.upvotes,
        downvotes: post.downvotes
    });

    // Emit notification if created
    if (notification) {
        global.io.to(`user_${post.author_id}`).emit('new-notification', notification);
    }

    res.status(200).json(new ApiResponse(200, post, "Post upvoted successfully"));
});

// Downvote post
export const downvotePost = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user._id;

    const post = await Post.findById(id).populate('author_id');
    if (!post) {
        throw new ApiError(404, "Post not found");
    }

    const hasUpvoted = post.upvotes.includes(userId);
    const hasDownvoted = post.downvotes.includes(userId);

    let notification = null;
    if (hasDownvoted) {
        // Remove downvote
        post.downvotes = post.downvotes.filter(id => id.toString() !== userId.toString());
    } else {
        // Add downvote and remove upvote if exists
        post.downvotes.push(userId);
        if (hasUpvoted) {
            post.upvotes = post.upvotes.filter(id => id.toString() !== userId.toString());
        }

        await logActivity(
            userId,
            "downvote",
            `${req.user.username || req.user.email || 'User'} downvoted post`,
            req,
            'post',
            id
        );

        // Create notification if not self-vote
        if (post.author_id.toString() !== userId.toString()) {
            notification = await Notification.create({
                user: post.author_id,
                type: "downvote",
                message: `${req.user.username || req.user.email || 'User'} downvoted your post`,
                relatedPost: id
            });
        }

        // Refresh recommendations after downvote
        await refreshRecommendations(userId);
    }

    // Calculate score
    post.score = post.upvotes.length - post.downvotes.length;

    await post.save();
    await post.populate('upvotes', 'username');
    await post.populate('downvotes', 'username');

    // Emit vote update to post room
    global.io.to(`post_${id}`).emit('vote-updated', {
        postId: id,
        upvotes: post.upvotes,
        downvotes: post.downvotes
    });

    // Emit notification if created
    if (notification) {
        global.io.to(`user_${post.author_id}`).emit('new-notification', notification);
    }

    res.status(200).json(new ApiResponse(200, post, "Post downvoted successfully"));
});

// Save post
export const savePost = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user._id;

    const post = await Post.findById(id);
    if (!post) {
        throw new ApiError(404, "Post not found");
    }

    const user = await User.findById(userId);
    if (!user) {
        throw new ApiError(404, "User not found");
    }

    // Check if post is already saved
    if (user.savedPosts.includes(id)) {
        throw new ApiError(400, "Post already saved");
    }

    // Add post to user's saved posts
    user.savedPosts.push(id);
    await user.save();

    // Refresh recommendations after saving
    await refreshRecommendations(userId);

    await logActivity(
        userId,
        "save-post",
        `${req.user.username || req.user.email || 'User'} saved post`,
        req,
        'post',
        id
    );

    res.status(200).json(new ApiResponse(200, null, "Post saved successfully"));
});

// Unsave post
export const unsavePost = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user._id;

    const post = await Post.findById(id);
    if (!post) {
        throw new ApiError(404, "Post not found");
    }

    const user = await User.findById(userId);
    if (!user) {
        throw new ApiError(404, "User not found");
    }

    // Check if post is saved
    if (!user.savedPosts.includes(id)) {
        throw new ApiError(400, "Post not saved");
    }

    // Remove post from user's saved posts
    user.savedPosts = user.savedPosts.filter(savedPostId => savedPostId.toString() !== id);
    await user.save();

    // Refresh recommendations after unsaving
    await refreshRecommendations(userId);

    await logActivity(
        userId,
        "unsave-post",
        `${req.user.username || req.user.email || 'User'} unsaved post`,
        req,
        'post',
        id
    );

    res.status(200).json(new ApiResponse(200, null, "Post unsaved successfully"));
});

// Get saved posts for the authenticated user
export const getSavedPosts = asyncHandler(async (req, res) => {
    const userId = req.user._id;
    const { page = 1, limit = 10 } = req.query;

    const user = await User.findById(userId);
    if (!user) {
        throw new ApiError(404, "User not found");
    }

    const savedPostIds = user.savedPosts;

    if (savedPostIds.length === 0) {
        return res.status(200).json(new ApiResponse(200, {
            posts: [],
            totalPages: 0,
            currentPage: page,
            totalPosts: 0
        }, "No saved posts found"));
    }

    const posts = await Post.find({ _id: { $in: savedPostIds } })
        .populate('author_id', 'username avatar')
        .populate('community_id', 'title members')
        .sort({ createdAt: -1 })
        .limit(limit * 1)
        .skip((page - 1) * limit);

    const totalPosts = savedPostIds.length;

    res.status(200).json(new ApiResponse(200, {
        posts,
        totalPages: Math.ceil(totalPosts / limit),
        currentPage: page,
        totalPosts
    }, "Saved posts fetched successfully"));
});

// Get recommended posts for the authenticated user
export const getRecommendedPosts = asyncHandler(async (req, res) => {
    const userId = req.user._id;

    const recommendedPostIds = await getRecommendations(userId);

    if (recommendedPostIds.length === 0) {
        return res.status(200).json(new ApiResponse(200, [], "No recommendations available"));
    }

    const posts = await Post.find({ _id: { $in: recommendedPostIds }, status: 'active' })
        .populate('author_id', 'username avatar')
        .populate('community_id', 'title members');

    // Sort posts based on the order of recommendedPostIds (API returns ranked order)
    const postMap = new Map(posts.map(post => [post._id.toString(), post]));
    const sortedPosts = recommendedPostIds.map(id => postMap.get(id)).filter(Boolean);

    res.status(200).json(new ApiResponse(200, sortedPosts, "Recommended posts fetched successfully"));
});

// Get recent posts (sorted by creation time)
export const getRecentPosts = asyncHandler(async (req, res) => {
    const { page = 1, limit = 10, communityName } = req.query;

    const filter = { status: 'active' };
    if (communityName) {
        const community = await Community.findOne({ name: communityName.toLowerCase() });
        if (community) {
            filter.community_id = community._id;
        } else {
            return res.status(200).json(new ApiResponse(200, {
                posts: [],
                totalPages: 0,
                currentPage: page,
                totalPosts: 0
            }, "Posts fetched successfully"));
        }
    }

    const posts = await Post.find(filter)
        .populate('author_id', 'username avatar')
        .populate('community_id', 'title members')
        .sort({ createdAt: -1 })
        .limit(limit * 1)
        .skip((page - 1) * limit);

    const totalPosts = await Post.countDocuments(filter);

    res.status(200).json(new ApiResponse(200, {
        posts,
        totalPages: Math.ceil(totalPosts / limit),
        currentPage: page,
        totalPosts
    }, "Recent posts fetched successfully"));
});

// Report a post
export const reportPost = asyncHandler(async (req, res, next) => {
    const { reason, description } = req.body;
    const postId = req.params.id;
    const reporterId = req.user._id;

    if (!reason || !description) {
        return next(new ErrorHandler("Reason and description are required", 400));
    }

    const post = await Post.findById(postId);
    if (!post) {
        return next(new ErrorHandler("Post not found", 404));
    }

    const report = new Report({
        reporter_id: reporterId,
        target_type: 'Post',
        target_id: postId,
        reason,
        status: 'open'
    });

    await report.save();

    res.status(201).json(new ApiResponse(201, report, "Post reported successfully"));
});