import { asyncHandler } from "../middlewares/asyncHandler.middleware.js";
import { Comment } from "../models/comment.model.js";
import { Post } from "../models/post.model.js";
import { Notification } from "../models/notification.model.js";
import { User } from "../models/user.model.js";
import { ApiError } from "../utils/ApiError.js";
import { ApiResponse } from "../utils/ApiResponse.js";
import { logActivity } from "../utils/logActivity.utils.js";
import { Report } from "../models/report.model.js";
import ErrorHandler from "../middlewares/error.middleware.js";
// Create a new comment
export const createComment = asyncHandler(async (req, res) => {
    const { body, postId, parentCommentId } = req.body;
    const author = req.user._id;

    if (!body || !postId) {
        throw new ApiError(400, "Body and postId are required");
    }

    const post = await Post.findById(postId);
    if (!post) {
        throw new ApiError(404, "Post not found");
    }

    let path = `${postId}`;
    if (parentCommentId) {
        const parentComment = await Comment.findById(parentCommentId);
        path = `${parentComment.path}`;
    }
    console.log("Report:", req.newReport ? req.newReport.label : 'safe');

    const comment = await Comment.create({
        body,
        author_id: author,
        post_id: postId,
        parent_id: parentCommentId || null,
        path: `${path}/temp`, // Temporary path
        status: req.newReport ? 'flagged' : 'active', // if spamDetector flagged it, set status to flagged
        label: req.detectionLabel || req.newReport?.label || 'safe',
        isSensitive: req.isSensitive || false
    });

    // If a report was generated by spamDetector middleware, save it
    if (req.newReport) {
        try {
            // remove extra fields from report
            delete req.newReport?.label

            req.newReport.target_type = "Comment";
            req.newReport.target_id = comment._id;

            const report = await Report.create(req.newReport);
            console.log("------Report Generated For Comment--------");
            console.log(report);
            console.log("--------------");
        } catch (err) {
            console.log("Error in creating report for comment create:", err.message);
            return res.send({ message: "Comment created but failed to create report" });
        }
    }


    // Set correct path after _id is available
    comment.path = `${path}/${comment._id}`;
    await comment.save();

    // Update num_comments on post
    post.num_comments += 1;
    await post.save();

    // If replying to a comment, update replies count
    if (parentCommentId) {
        const parentComment = await Comment.findById(parentCommentId);
        parentComment.replies_count += 1;
        await parentComment.save();
    }

    await comment.populate('author_id', 'username avatar');
    await comment.populate('post_id', 'title');

    await logActivity(
        author,
        "reply",
        `${req.user.username} created a comment`,
        req,
        'comment',
        comment._id
    );

    // Increment num_comments for user
    await User.findByIdAndUpdate(author, { $inc: { num_comments: 1 } });

    // Create notification for post author if not self-comment
    if (post.author_id.toString() !== author.toString()) {
        const notification = await Notification.create({
            user: post.author_id,
            type: "comment",
            message: `${req.user.username} commented on your post`,
            relatedPost: postId,
            relatedComment: comment._id
        });

        // Emit real-time notification
        global.io.to(`user_${post.author_id}`).emit('new-notification', notification);
    }

    // Create notification for parent comment author if replying
    if (parentCommentId) {
        const parentComment = await Comment.findById(parentCommentId).populate('author_id');
        if (parentComment.author_id._id.toString() !== author.toString()) {
            const replyNotification = await Notification.create({
                user: parentComment.author_id._id,
                type: "reply",
                message: `${req.user.username} replied to your comment`,
                relatedPost: postId,
                relatedComment: comment._id
            });

            // Emit real-time notification
            global.io.to(`user_${parentComment.author_id._id}`).emit('new-notification', replyNotification);
        }
    }

    // Emit comment update to post room
    global.io.to(`post_${postId}`).emit('comment-added', {
        comment: await comment.populate('author_id', 'username avatar'),
        postId
    });

    const responseData = req.newReport ? { comment, flagged: true, flag_message: 'Comment flagged as possible spam/toxicity and will be reviewed by moderators.' } : comment;
    res.status(201).json(new ApiResponse(201, responseData, "Comment created successfully"));
});

// Get comments for a post
export const getCommentsForPost = asyncHandler(async (req, res) => {
    const { postId } = req.params;
    const { page = 1, limit = 10 } = req.query;

    const comments = await Comment.find({ post_id: postId, parent_id: null })
        .populate('author_id', 'username avatar')
        .sort({ createdAt: -1 })
        .limit(limit * 1)
        .skip((page - 1) * limit);

    const totalComments = await Comment.countDocuments({ post_id: postId, parent_id: null });

    res.status(200).json(new ApiResponse(200, {
        comments,
        totalPages: Math.ceil(totalComments / limit),
        currentPage: page,
        totalComments
    }, "Comments fetched successfully"));
});

// Get comments by user
export const getCommentsByUser = asyncHandler(async (req, res) => {
    const { userId } = req.params;
    const { page = 1, limit = 10, sortBy = "createdAt" } = req.query;

    const comments = await Comment.find({ author_id: userId })
        .populate('author_id', 'username avatar')
        .populate('post_id', 'title')
        .sort({ [sortBy]: -1 })
        .limit(limit * 1)
        .skip((page - 1) * limit);

    const totalComments = await Comment.countDocuments({ author_id: userId });

    res.status(200).json(new ApiResponse(200, {
        comments,
        totalPages: Math.ceil(totalComments / limit),
        currentPage: page,
        totalComments
    }, "User comments fetched successfully"));
});

// Get replies for a comment
export const getRepliesForComment = asyncHandler(async (req, res) => {
    const { commentId } = req.params;
    const { page = 1, limit = 10 } = req.query;

    const replies = await Comment.find({ parent_id: commentId })
        .populate('author_id', 'username avatar')
        .sort({ createdAt: 1 })
        .limit(limit * 1)
        .skip((page - 1) * limit);

    const totalReplies = await Comment.countDocuments({ parent_id: commentId });

    res.status(200).json(new ApiResponse(200, {
        replies,
        totalPages: Math.ceil(totalReplies / limit),
        currentPage: page,
        totalReplies
    }, "Replies fetched successfully"));
});

// Update comment (only author)
export const updateComment = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const { body } = req.body;
    const userId = req.user._id;

    const comment = await Comment.findById(id);
    if (!comment) {
        throw new ApiError(404, "Comment not found");
    }

    if (comment.author_id.toString() !== userId.toString()) {
        throw new ApiError(403, "Only author can update comment");
    }

    // If a report was generated by spamDetector middleware, save it
    if (req.newReport) {
        try {
            // remove extra fields from report
            delete req.newReport?.label;

            req.newReport.target_type = "Comment";
            req.newReport.target_id = comment._id;

            const report = await Report.create(req.newReport);
            console.log("------Report Generated For Comment--------");
            console.log(report);
            console.log("--------------");
        } catch (err) {
            console.log("Error in creating report for comment update:", err.message);
            return res.send({ message: "Comment updated but failed to create report" });
        }
    }

    comment.body = body || comment.body;
    comment.label = req.detectionLabel || req.newReport?.label || 'safe';
    comment.status = req.newReport ? 'flagged' : comment.status; // if spamDetector flagged it, set status to flagged
    comment.isSensitive = req.isSensitive || comment.isSensitive;
    await comment.save();

    await comment.populate('author_id', 'username avatar');

    await logActivity(
        userId,
        "update-reply",
        `${req.user.username} updated comment`,
        req,
        'comment',
        id
    );

    const updateResponseData = req.newReport ? { comment, flagged: true, flag_message: 'Comment flagged as possible spam/toxicity and will be reviewed by moderators.' } : comment;
    res.status(200).json(new ApiResponse(200, updateResponseData, "Comment updated successfully"));
});

// Delete comment (author or moderator)
export const deleteComment = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user._id;

    const comment = await Comment.findById(id).populate('post_id');
    if (!comment) {
        throw new ApiError(404, "Comment not found");
    }

    const isAuthor = comment.author_id.toString() === userId.toString();
    const isModerator = comment.post_id.community.moderators.includes(userId);

    if (!isAuthor && !isModerator) {
        throw new ApiError(403, "Only author or moderator can delete comment");
    }

    await logActivity(
        userId,
        "delete-reply",
        `${req.user.username} deleted comment`,
        req,
        'comment',
        id
    );

    // Update counts
    const post = await Post.findById(comment.post_id);
    post.num_comments -= 1;
    await post.save();

    if (comment.parent_id) {
        const parentComment = await Comment.findById(comment.parent_id);
        parentComment.replies_count -= 1;
        await parentComment.save();
    }

    if (isAuthor) {
        // Author deletes: set status to removed, clear body
        comment.status = 'removed';
        comment.body = '';
        await comment.save();
        // Decrement num_comments for user
        await User.findByIdAndUpdate(userId, { $inc: { num_comments: -1 } });
    } else {
        // Moderator deletes: delete completely
        await Comment.findByIdAndDelete(id);
    }

    res.status(200).json(new ApiResponse(200, null, "Comment deleted successfully"));
});

// Upvote comment
export const upvoteComment = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user._id;

    const comment = await Comment.findById(id).populate('author_id').populate('post_id');
    if (!comment) {
        throw new ApiError(404, "Comment not found");
    }

    const hasUpvoted = comment.upvotes.includes(userId);
    const hasDownvoted = comment.downvotes.includes(userId);

    let notification = null;
    if (hasUpvoted) {
        comment.upvotes = comment.upvotes.filter(id => id.toString() !== userId.toString());
    } else {
        comment.upvotes.push(userId);
        if (hasDownvoted) {
            comment.downvotes = comment.downvotes.filter(id => id.toString() !== userId.toString());
        }

        await logActivity(
            userId,
            "upvote",
            `${req.user.username} upvoted comment`,
            req,
            'comment',
            id
        );

        // Create notification if not self-vote
        if (comment.author_id._id.toString() !== userId.toString()) {
            notification = await Notification.create({
                user: comment.author_id._id,
                type: "upvote",
                message: `${req.user.username} upvoted your comment`,
                relatedPost: comment.post_id._id,
                relatedComment: id
            });
        }
    }

    // Calculate score
    comment.score = comment.upvotes.length - comment.downvotes.length;

    await comment.save();
    await comment.populate('upvotes', 'username');
    await comment.populate('downvotes', 'username');

    // Emit vote update to post room
    global.io.to(`post_${comment.post_id._id}`).emit('comment-vote-updated', {
        commentId: id,
        upvotes: comment.upvotes,
        downvotes: comment.downvotes
    });

    // Emit notification if created
    if (notification) {
        global.io.to(`user_${comment.author_id._id}`).emit('new-notification', notification);
    }

    res.status(200).json(new ApiResponse(200, comment, "Comment upvoted successfully"));
});

// Downvote comment
export const downvoteComment = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const userId = req.user._id;

    const comment = await Comment.findById(id).populate('author_id').populate('post_id');
    if (!comment) {
        throw new ApiError(404, "Comment not found");
    }

    const hasUpvoted = comment.upvotes.includes(userId);
    const hasDownvoted = comment.downvotes.includes(userId);

    let notification = null;
    if (hasDownvoted) {
        comment.downvotes = comment.downvotes.filter(id => id.toString() !== userId.toString());
    } else {
        comment.downvotes.push(userId);
        if (hasUpvoted) {
            comment.upvotes = comment.upvotes.filter(id => id.toString() !== userId.toString());
        }

        await logActivity(
            userId,
            "downvote",
            `${req.user.username} downvoted comment`,
            req,
            'comment',
            id
        );

        // Create notification if not self-vote
        if (comment.author_id._id.toString() !== userId.toString()) {
            notification = await Notification.create({
                user: comment.author_id._id,
                type: "downvote",
                message: `${req.user.username} downvoted your comment`,
                relatedPost: comment.post_id._id,
                relatedComment: id
            });
        }
    }

    // Calculate score
    comment.score = comment.upvotes.length - comment.downvotes.length;

    await comment.save();
    await comment.populate('upvotes', 'username');
    await comment.populate('downvotes', 'username');

    // Emit vote update to post room
    global.io.to(`post_${comment.post_id._id}`).emit('comment-vote-updated', {
        commentId: id,
        upvotes: comment.upvotes,
        downvotes: comment.downvotes
    });

    // Emit notification if created
    if (notification) {
        global.io.to(`user_${comment.author_id._id}`).emit('new-notification', notification);
    }

    res.status(200).json(new ApiResponse(200, comment, "Comment downvoted successfully"));
});

// Report a comment
export const reportComment = asyncHandler(async (req, res, next) => {
    const { reason, description } = req.body;
    const commentId = req.params.id;
    const reporterId = req.user._id;

    if (!reason || !description) {
        return next(new ErrorHandler("Reason and description are required", 400));
    }

    const comment = await Comment.findById(commentId);
    if (!comment) {
        return next(new ErrorHandler("Comment not found", 404));
    }

    const report = new Report({
        reporter_id: reporterId,
        target_type: 'Comment',
        target_id: commentId,
        reason,
        status: 'open'
    });

    await report.save();

    res.status(201).json(new ApiResponse(201, report, "Comment reported successfully"));
});